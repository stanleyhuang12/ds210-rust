



STRINGS (built-in methods)
    ,parse (convert a string representation into text)

unsigned integers: 
- Positive
- u8, u16, u32, u64, u128 or usize (default on your machine is like 32)
- the number of bits you want to allocate for each number 

0 2^n-1 numbers 
    9 to 255 for u8 
    2^8 = 256 numbers i can represent 0-255 
    nsigned Integer	Unsigned 8 bit binary

0	00000000
1	00000001 
2	00000010
3	00000011

signed integer 
    -128 to 127 = together is 256 values 

Signed Integer	Signed 8 bit binary
    0	00000000
    1	00000001
    2	00000010
    3	00000011
    -1	11111111
    -2	11111110
    -3	11111101
from the left handside we can add by 2^n where n is the place from the rightmost value 

To convert a positive integer to a negative integer: we follow the twos complement procedure 

Step 1: Represent in bits 
00000111 = 2^0 + 2^1 + 2^2 = 1 + 2 + 4 = 7 

Step 2: Invert the bits 
11111000 

Step 3: Add a 1 to the last bit 
11111001 = this represents - 7 

Step 4: We know the bit representation is negative because it has a leading 1 
To read we can flip all the representations 

    00000110 = 6 
    6 + 1 = 7 
    negate it again so that it is read as -7 


## Character and String Data types

Character: 'c' '<insert emoji>' 

Initially each character were 8 bits (byte) and represented ASCII, some numbers and mathematical symbols, Roman characters, etc...
Later, they use UTF-8 encoding to encode each string 


Strings can be thought of as a more complex representations of characters. In Rust, string is not a native type but can be thought of as a more complicated wrapper around other data types 

Strings: "hello"
String slices: &str [immutable ]

Two types of string representations: 

**String**: 
String::("...")
",,,".to_string()
- mutable and growable 
- built on vec<u8> which is a vector representation of the encoding that is malleable

**string slices**
"..."
- immutable on &<u8> which is an immutable reference of the byte representations 





fn main() {
    ### STRING SLICES or STRING REFERENCES 
    let s1 = "Hello! How are you, ðŸ¦•?";  // creates immutable borrowed reference to a string slice: `&str`
    let s2 : &str = "ÎšÎ±Î»Î·Î¼Î­ÏÎ± Î±Ï€ÏŒ Ï„Î·Î½ Î’Î¿ÏƒÏ„ÏŽÎ½Î· ÎºÎ±Î¹ Ï„Î·Î½ DS210";  // here we make the type explicit

    ## STRING LITERALS, DYNAMIC AND GROWABLE. I CAN ADD MORE 
    let s3: String = "Hello! How are you" doesn't work because "..." is a string slice reference being populated in S3 which is explicitly typed as String

    let s3: String = "Hello! How are you".to_string() performs a conversation of a string slice to string literal and then feeds it into s3 
    
    let s4: String = String::from("Hello! How are you?") the base datatype converts the string slices (immutable reference)

    s1.chars() -> treat it as an array of characters or Vec<8> 
    .nth(3) -> the 3rd value of the array
    .unwrap() -> convert to a format I want to use 

    println!("{}", s1);
    println!("{}\n", s2);
}




